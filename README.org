#+title: Mongoose

This library contains Common Lisp bindings to the [[https://mongoose.ws][Mongoose]] web server / client
library written in C. Internally Mongoose is event based and so can handle
decent concurrent load, but it is otherwise single-threaded in nature.

This library has no Common Lisp dependencies, and Mongoose itself by default
only requires =openssl=.

* Table of Contents :TOC_5_gh:noexport:
- [[#compatibility][Compatibility]]
- [[#installation][Installation]]
  - [[#arch-linux][Arch Linux]]
  - [[#macos][MacOS]]
  - [[#from-source][From Source]]
- [[#usage][Usage]]
  - [[#http-server][HTTP Server]]
    - [[#handlers-and-the-polling-loop][Handlers and the Polling Loop]]
    - [[#serving-static-files][Serving Static Files]]
    - [[#routing][Routing]]
    - [[#query-parameters][Query Parameters]]
    - [[#html][HTML]]
    - [[#headers][Headers]]
    - [[#tls-https][TLS (HTTPS)]]
    - [[#logging][Logging]]
  - [[#http-client][HTTP Client]]
- [[#performance][Performance]]
  - [[#measurements][Measurements]]
  - [[#tips][Tips]]
    - [[#make-alien-vs-with-alien][make-alien vs with-alien]]
- [[#related-work][Related Work]]

* Compatibility

The FFI bindings are hand-written for maximum performance and minimum dependency
load. Currently only SBCL is supported.

| Compiler  | Compiles? |
|-----------+-----------|
| SBCL      | ✅        |
| ECL       | ❌        |
| Clasp     | ❌        |
| ABCL      | ❌        |
| CCL       | ❌        |
| Clisp     | ❌        |
|-----------+-----------|
| Allegro   | ❌        |
| LispWorks | ❌        |

* Installation

This library requires Mongoose to be available on your system.

** Arch Linux

Mongoose is available from [[https://aur.archlinux.org/packages/mongoose][the AUR]].

#+begin_example
aura -A mongoose
#+end_example

** MacOS

Mongoose is available [[https://formulae.brew.sh/formula/mongoose][with Homebrew]].

#+begin_example
brew install mongoose
#+end_example

** From Source

By design Mongoose is simple and has no complex build process. Simply [[https://github.com/cesanta/mongoose/][acquire
its source code]], compile a =.so=, and make it available as
=/usr/lib/libmongoose.so=.

* Usage

See also the official [[https://mongoose.ws/documentation][Mongoose Documentation]].

As a rule, the functions and types provided here have the same names as their
underlying C ones, except that the =mg_= prefix has been stripped and underscores
are now dashes (e.g. =mg_http_serve_dir -> http-serve-dir=).

=(in-package :mongoose)= has been used for brevity in the examples below, but it's
assumed that you'll use a package nickname in your own code, perhaps =mg=.

Note also that for simplicity, no higher level Lisp API has been provided on top
of Mongoose itself. We will occasionally be using FFI primitives directly, but
you will see that this is not a stressful activity. Some small helper functions
have been provided where appropriate.

** HTTP Server

*** Handlers and the Polling Loop

I could have provided some macro-based =defhandler=, etc., but I realized that
such an interface already exists: the FFI itself, which we will embrace in the
spirit of minimalism.

Mongoose operates in a single-threaded "polling loop".

#+begin_src lisp
(loop (mgr-poll mgr 1000))
#+end_src

Where =mgr= is an underlying [[https://mongoose.ws/documentation/#struct-mg_addr][mg_mgr]] you've already initialized, the 1000
milliseconds is a timeout for accepting incoming connections, and =mgr-poll=
itself is just a direct call to [[https://mongoose.ws/documentation/#mg_mgr_poll][mg_mgr_poll]].

Your "main" will look something like this:

#+begin_src lisp
(let ((mgr (make-alien mgr)))
  (mgr-init mgr)
  (let ((handler (alien-sap (alien-callable-function 'ev-handler))))
    (http-listen mgr "http://localhost:8000" handler nil))
  (loop (mgr-poll mgr 1000))
  (mgr-free mgr)
  (free-alien mgr))
#+end_src

Of note:

- =make-alien=: this initializes some memory that we immediately populate with
  =mgr-init=.
- =(alien-sap (alien-callable-function ...))=: Mongoose needs a C-level function
  pointer to its main event handler, and this is how we produce one from the
  Lisp side.

But what is ='ev-handler= referring to? And how can we pass a pointer to a C
function when we aren't writing C? The answer is =define-alien-callable=.

#+begin_src lisp
(define-alien-callable ev-handler void ((c (* connection)) (ev int) (ev-data (* t)))
  "Handle HTTP events."
  (when (= ev +ev-http-msg+)
    (let ((hm (cast ev-data (* http-message))))
      ;; Do whatever!
      (foo hm))))
#+end_src

As you'll later see in the Examples, our handler will always take this basic
shape. =define-alien-callable= enables us to write _whatever Lisp we want_ for our
handler logic, and have C call into it. It even supports hot reloading as usual;
our server can already be running, we can hot recompile just this handler, and
the changes will be immediately reflected.

You can see that the input and output types of the handler are C types. The =(*
connection)= syntax (etc.) is provided by =sb-alien=, the main FFI module within
SBCL. You can also see us doing a Pointer Cast via =cast= to get access to the
request payload - this is standard practice with Mongoose.

If you need access to the fields of C structs, use =slot= as can be seen in [[file:examples/01-routing.lisp][this
example]]. 

*** Serving Static Files

We get this for free via =http-serve-dir=.

See [[file:examples/00-static-files.lisp]].

*** Routing

Keeping it simple, routing is a matter of extracting the =uri= field of a
=http-message= and doing string matching on it.

See [[file:examples/01-routing.lisp]].

*** Query Parameters

See [[file:examples/03-query-params.lisp]].

*** HTML

You're free to use any HTML library you wish, provided it eventually yields a
concrete string to pass through the FFI. For a solution with zero transitive
dependencies, consider [[https://github.com/fosskers/html][html]].

See [[file:examples/02-html.lisp]].

*** Headers
*** TLS (HTTPS)

#+begin_quote
⚠ Coming soon! ⚠

Not yet possible until the recent struct-by-value work in SBCL is released.
Mongoose's TLS functions have one specific place, related to their internal
string type, where this is necessary.
#+end_quote

*** Logging

Mongoose does its own logging, which you will see if running an actual Lisp
program (but not through the REPL). By default many messages are printed -
enough to lower latency. To change this, simply alter the value of =*log-level*=.

#+begin_src lisp
(in-package :mongoose)

(let ((mgr (make-alien mgr)))
  (setf *log-level* +ll-error+)
  (mgr-init mgr)
  ;; ... etc. ...
  (mgr-free mgr)
  (free-alien mgr))
#+end_src

The available log levels are:

- =+ll-none+=
- =+ll-error+=
- =+ll-info+=
- =+ll-debug+= (the default)
- =+ll-verbose+=

** HTTP Client

* Performance

** Measurements

See =sample.c= for a trivial baseline server and =repl.lisp= for its Common Lisp
analogue. The following command:

#+begin_example
echo "GET http://localhost:8000/html" | vegeta attack -duration=10s -rate=0 -max-workers=4 | tee results.bin | vegeta report
#+end_example

produces these results on my 2018 ThinkPad (I write this in January 2026). The
only attempt to optimize either code was to disable logging.

| Language | Requests-per-Second |
|----------+---------------------|
| Lisp     |               23600 |
| C        |               25000 |

There are some string-related inefficiencies in the Lisp that could easily be
worked around in production code, thus I am willing to claim that for practical
purposes the FFI can be trusted not to introduce undue overhead.

** Tips

*** make-alien vs with-alien

* Related Work
